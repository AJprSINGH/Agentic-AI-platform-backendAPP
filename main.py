from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
<<<<<<< HEAD
import uuid
import logging
from database import get_db
from models import (
    DBAgent, DBRun, DBTask, DBReflection, DBFeedback,
    AgentCreate, TaskUpdate, ReflectionCreate, FeedbackCreate,
    AgentResponse, RunResponse, TaskResponse, ReflectionResponse,
    RunTraceResponse, FeedbackResponse, RunStartResponse
)

app = FastAPI(title="Agent API - Memory & Logging")

=======
import logging
import os
import uuid
from database import get_db
from models import (
    DBAgent, DBRun, DBTask, DBReflection, DBFeedback,
    AgentCreate, AgentUpdate, TaskUpdate, ReflectionCreate, FeedbackCreate,
    AgentResponse, RunResponse, TaskResponse, ReflectionResponse,
    RunTraceResponse, FeedbackResponse, RunStartResponse
)
from policy_middleware import PolicyMiddleware

app = FastAPI(title="Agent API - Memory & Logging")

# Initialize policy middleware
policy_path = os.getenv("POLICY_PATH", "./agent_policy.yaml")
policy_middleware = PolicyMiddleware(policy_path)

>>>>>>> a2600ba (update 30/12/2025- 4pm)
@app.get("/health")
def health_check():
    return {"status": "healthy"}

<<<<<<< HEAD
@app.post("/agents")
def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
    new_agent = DBAgent(name=agent.name, role=agent.role)
    db.add(new_agent)
    db.commit()
    db.refresh(new_agent)
    return new_agent

@app.post("/agents/{agent_id}/run", response_model=RunStartResponse)
def start_run(agent_id: uuid.UUID, db: Session = Depends(get_db)):
    new_run = DBRun(agent_id=agent_id, status="started")
=======
@app.post("/agents", response_model=AgentResponse)
def create_agent(agent: AgentCreate, db: Session = Depends(get_db)):
    new_agent = DBAgent(
        name=agent.name,
        description=agent.description,
        module=agent.module,
        sub_module=agent.sub_module,
        role=agent.role,
        temperature=agent.temperature,
        max_tokens=agent.max_tokens,
        system_prompt=agent.system_prompt
    )
    db.add(new_agent)
    db.commit()
    db.refresh(new_agent)
    return AgentResponse(
        agent_id=new_agent.id,
        name=new_agent.name,
        description=new_agent.description,
        module=new_agent.module,
        sub_module=new_agent.sub_module,
        status=new_agent.status,
        created_at=new_agent.created_at.isoformat(),
        temperature=new_agent.temperature,
        max_tokens=new_agent.max_tokens,
        system_prompt=new_agent.system_prompt
    )

@app.get("/agents", response_model=list[AgentResponse])
def get_agents(status: str = None, db: Session = Depends(get_db)):
    query = db.query(DBAgent)
    if status:
        query = query.filter(DBAgent.status == status)
    agents = query.all()
    return [
        AgentResponse(
            agent_id=agent.id,
            name=agent.name,
            description=agent.description,
            module=agent.module,
            sub_module=agent.sub_module,
            status=agent.status,
            created_at=agent.created_at.isoformat(),
            temperature=agent.temperature,
            max_tokens=agent.max_tokens,
            system_prompt=agent.system_prompt
        ) for agent in agents
    ]

@app.get("/agents/deployed", response_model=list[AgentResponse])
def get_deployed_agents(db: Session = Depends(get_db)):
    agents = db.query(DBAgent).filter(DBAgent.status == "deployed").all()
    return [
        AgentResponse(
            agent_id=agent.id,
            name=agent.name,
            description=agent.description,
            module=agent.module,
            sub_module=agent.sub_module,
            status=agent.status,
            created_at=agent.created_at.isoformat(),
            temperature=agent.temperature,
            max_tokens=agent.max_tokens,
            system_prompt=agent.system_prompt
        ) for agent in agents
    ]

@app.patch("/agents/{agent_id}", response_model=AgentResponse)
def update_agent(agent_id: str, agent_update: AgentUpdate, db: Session = Depends(get_db)):
    agent = db.query(DBAgent).filter(DBAgent.id == agent_id).first()
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")
    agent.status = agent_update.status
    db.commit()
    db.refresh(agent)
    return AgentResponse(
        agent_id=agent.id,
        name=agent.name,
        description=agent.description,
        module=agent.module,
        sub_module=agent.sub_module,
        status=agent.status,
        created_at=agent.created_at.isoformat(),
        temperature=agent.temperature,
        max_tokens=agent.max_tokens,
        system_prompt=agent.system_prompt
    )

@app.post("/agents/{agent_id}/run", response_model=RunStartResponse)
def start_run(agent_id: str, db: Session = Depends(get_db)):
    # Verify agent_id is a valid UUID and agent exists
    try:
        agent_uuid = uuid.UUID(agent_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid agent_id format")

    agent = db.query(DBAgent).filter(DBAgent.id == agent_uuid).first()
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    new_run = DBRun(agent_id=agent_uuid, status="started")
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    db.add(new_run)
    db.commit()
    db.refresh(new_run)

    # Create initial task
    new_task = DBTask(run_id=new_run.id, description="Execute agent run tasks")
    db.add(new_task)
    db.commit()
    db.refresh(new_task)

    return RunStartResponse(
        run=RunResponse(
            id=new_run.id,
            agent_id=new_run.agent_id,
            status=new_run.status,
            created_at=new_run.created_at.isoformat()
        ),
        task=TaskResponse(
            id=new_task.id,
            run_id=new_task.run_id,
            description=new_task.description,
            status=new_task.status,
            result=new_task.result,
            error=new_task.error,
            created_at=new_task.created_at.isoformat()
        )
    )

# Endpoint to update Task Result (Logging)
@app.patch("/tasks/{task_id}")
<<<<<<< HEAD
def update_task(task_id: uuid.UUID, data: TaskUpdate, db: Session = Depends(get_db)):
=======
def update_task(task_id: str, data: TaskUpdate, db: Session = Depends(get_db)):
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    task = db.query(DBTask).filter(DBTask.id == task_id).first()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    task.status = data.status
    if data.result: task.result = data.result
    if data.error: task.error = data.error
    db.commit()
    return task

# Endpoint to add Reflection (Memory)
@app.post("/runs/{run_id}/reflections", response_model=ReflectionResponse)
<<<<<<< HEAD
def add_reflection(run_id: uuid.UUID, reflection: ReflectionCreate, db: Session = Depends(get_db)):
=======
def add_reflection(run_id: str, reflection: ReflectionCreate, db: Session = Depends(get_db)):
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    logging.info(f"Adding reflection for run_id: {run_id}")
    # Verify run exists
    run = db.query(DBRun).filter(DBRun.id == run_id).first()
    if not run:
        logging.error(f"Run not found for run_id: {run_id}")
        raise HTTPException(status_code=404, detail="Run not found")

    logging.info(f"Run found: {run.id}")
    new_ref = DBReflection(run_id=run_id, content=reflection.content)
    db.add(new_ref)
    db.commit()
    db.refresh(new_ref)
    logging.info(f"Reflection added: {new_ref.id}")
    return ReflectionResponse(
        id=new_ref.id,
        run_id=new_ref.run_id,
        content=new_ref.content,
        created_at=new_ref.created_at.isoformat()
    )

# Endpoint to fetch all runs
@app.get("/runs", response_model=list[RunResponse])
def get_runs(db: Session = Depends(get_db)):
    runs = db.query(DBRun).all()
    return [
        RunResponse(
            id=run.id,
            agent_id=run.agent_id,
            status=run.status,
            created_at=run.created_at.isoformat()
        ) for run in runs
    ]

# Endpoint to fetch a specific run
@app.get("/runs/{run_id}", response_model=RunResponse)
<<<<<<< HEAD
def get_run(run_id: uuid.UUID, db: Session = Depends(get_db)):
=======
def get_run(run_id: str, db: Session = Depends(get_db)):
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    run = db.query(DBRun).filter(DBRun.id == run_id).first()
    if not run:
        raise HTTPException(status_code=404, detail="Run not found")
    return RunResponse(
        id=run.id,
        agent_id=run.agent_id,
        status=run.status,
        created_at=run.created_at.isoformat()
    )

# Endpoint to fetch run trace (complete execution history)
@app.get("/runs/{run_id}/trace", response_model=RunTraceResponse)
<<<<<<< HEAD
def get_run_trace(run_id: uuid.UUID, db: Session = Depends(get_db)):
=======
def get_run_trace(run_id: str, db: Session = Depends(get_db)):
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    run = db.query(DBRun).filter(DBRun.id == run_id).first()
    if not run:
        raise HTTPException(status_code=404, detail="Run not found")
    
    tasks = db.query(DBTask).filter(DBTask.run_id == run_id).all()
    reflections = db.query(DBReflection).filter(DBReflection.run_id == run_id).all()
    
    return RunTraceResponse(
        run=RunResponse(
            id=run.id,
            agent_id=run.agent_id,
            status=run.status,
            created_at=run.created_at.isoformat()
        ),
        tasks=[
            TaskResponse(
                id=task.id,
                run_id=task.run_id,
                description=task.description,
                status=task.status,
                result=task.result,
                error=task.error,
                created_at=task.created_at.isoformat()
            ) for task in tasks
        ],
        reflections=[
            ReflectionResponse(
                id=ref.id,
                run_id=ref.run_id,
                content=ref.content,
                created_at=ref.created_at.isoformat()
            ) for ref in reflections
        ]
    )

# Endpoint to submit feedback
@app.post("/runs/{run_id}/feedback", response_model=FeedbackResponse)
<<<<<<< HEAD
def submit_feedback(run_id: uuid.UUID, feedback: FeedbackCreate, db: Session = Depends(get_db)):
=======
def submit_feedback(run_id: str, feedback: FeedbackCreate, db: Session = Depends(get_db)):
>>>>>>> a2600ba (update 30/12/2025- 4pm)
    # Verify run exists
    run = db.query(DBRun).filter(DBRun.id == run_id).first()
    if not run:
        raise HTTPException(status_code=404, detail="Run not found")
<<<<<<< HEAD
    
    new_feedback = DBFeedback(run_id=run_id, rating=str(feedback.rating), comment=feedback.comment)
    db.add(new_feedback)
    db.commit()
    db.refresh(new_feedback)
    
=======

    new_feedback = DBFeedback(run_id=run_id, rating=feedback.rating, comment=feedback.comment)
    db.add(new_feedback)
    db.commit()
    db.refresh(new_feedback)

>>>>>>> a2600ba (update 30/12/2025- 4pm)
    return FeedbackResponse(
        id=new_feedback.id,
        run_id=new_feedback.run_id,
        rating=int(new_feedback.rating),
        comment=new_feedback.comment,
        created_at=new_feedback.created_at.isoformat()
<<<<<<< HEAD
    )
=======
    )

# Governance endpoints
@app.get("/audit-log")
def get_audit_log(filter_violations: bool = False):
    return {"audit_log": policy_middleware.get_audit_log(filter_violations)}

@app.get("/rate-limits")
def get_rate_limits():
    return policy_middleware.get_rate_limit_status()

# Metrics endpoint
@app.get("/metrics")
def get_metrics():
    # Simple metrics: count of runs, tasks, etc.
    # In real implementation, use prometheus or similar
    return {
        "total_runs": 0,  # Would query DB
        "successful_runs": 0,
        "average_latency": 0.0,
        "success_score": 0.0
    }

# Manual override endpoint
@app.post("/governance/override")
def manual_override(action: str, module: str, reason: str):
    # Allow admin to override policy
    # In real implementation, check auth
    policy_middleware.audit_log.append(f"[MANUAL OVERRIDE] {action} in {module} - Reason: {reason}")
    return {"status": "override_granted"}

# Approval-required actions endpoint
@app.post("/governance/approve-action")
def approve_action(action: str, module: str, approved: bool):
    if approved:
        policy_middleware.audit_log.append(f"[APPROVAL GRANTED] {action} in {module}")
        return {"status": "approved"}
    else:
        policy_middleware.audit_log.append(f"[APPROVAL DENIED] {action} in {module}")
        return {"status": "denied"}
>>>>>>> a2600ba (update 30/12/2025- 4pm)
